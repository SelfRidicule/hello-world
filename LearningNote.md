- JS ES5 [教程](https://wangdoc.com/javascript/)
- JS ES6 新语法 [教程](http://es6.ruanyifeng.com/#README)

let 和 const 命令:
  1.不存在的变量提升 : var命令会发生“变量提升”现象，即变量可以在声明之前使用，值为undefined 。为了纠正这种现象 let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。
  2.暂时性死区 : 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。
  3.不允许重复声明 : let不允许在相同作用域内，重复声明同一个变量。
  4.ES5块级作用域 : ES5 只有全局作用域和函数作用域，没有块级作用域，第一种场景，内层变量可能会覆盖外层变量。，原因在于变量提升，导致内层的变量覆盖了外层的变量。第二种场景，内层变量泄露为全局变量。，原因在于变量提升。
  5.ES6块级作用域 : let实际上为 JavaScript 新增了块级作用域。ES6 允许块级作用域的任意嵌套( {{console.log(123)}} )。每一层都是一个单独的作用域，外层作用域无法读取内层作用域的内部变量。内层作用域可以定义外层作用域的同名变量。
  6.const声明一个只读的常量。一旦声明，常量的值就不能改变。
  7.const本质: 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。
  8.ES6 声明变量的六种方法: var，function，let，const，import，class。
  9.顶层对象: 顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。

变量的解构赋值:
  1.ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。
  2.解构赋值允许指定默认值。注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。
  3.对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。
  4.如果解构失败，变量的值等于undefined。
  
箭头函数:
  1.ES6 允许使用“箭头”（=>）定义函数。
    var f = v => v;
  2.如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。
    var sum = (num1, num2) => num1 + num2;
  3.如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。
    var sum = (num1, num2) => { return num1 + num2; }
  4.由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。
    let getTempItem = id => ({ id: id, name: "Temp" });
  5.如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。
    let fn = () => void doesNotReturn();
  6.箭头函数可以与变量解构结合使用。
    const full = ({ first, last }) => first + ' ' + last;
  7.箭头函数有几个使用注意点。
    1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
    2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
    3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
    4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
  8.箭头函数根本没有自己的this , 指向最靠近外层的this。除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、            new.target。
  9.在function里this关键字总是指向函数所在的当前对象。

尾调用:
  1.尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。
  2.尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。
  3.目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。

尾递归:
  1.函数调用自身，称为递归。如果尾调用自身，就称为尾递归。
  2.递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。
  3.递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。

扩展运算符:
  1.扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
    console.log(...[1, 2, 3])
  2.如果扩展运算符后面是一个空数组，则不产生任何效果。
    [...[], 1] 
    // [1]
  3.只有函数调用时，扩展运算符才可以放在圆括号中，否则会报错。
    (...[1, 2])
    // Uncaught SyntaxError: Unexpected number

    console.log((...[1, 2]))
    // Uncaught SyntaxError: Unexpected number

    console.log(...[1, 2])
    // 1 2
  4.合并数组
    // ES6 的合并数组
    [...arr1, ...arr2, ...arr3]

    // ES6 的写法(push方法的参数不能是数组)
    let arr1 = [0, 1, 2];
    let arr2 = [3, 4, 5];
    arr1.push(...arr2);
  5.与解构赋值结合
    const [first, ...rest] = [1, 2, 3, 4, 5];
    first // 1
    rest  // [2, 3, 4, 5]

    如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。
    const [...butLast, last] = [1, 2, 3, 4, 5];
    // 报错
  
  6.对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。
    let z = { a: 3, b: 4 };
    let n = { ...z };
    n // { a: 3, b: 4 }

  7.如果扩展运算符后面是一个空对象，则没有任何效果。
    {...{}, a: 1}
    // { a: 1 }

  8.如果扩展运算符后面不是对象，则会自动将其转为对象。由于该对象没有自身属性，所以返回一个空对象。
    // 等同于 {...Object(true)}
    {...true} // {}

    // 等同于 {...Object(undefined)}
    {...undefined} // {}

    // 等同于 {...Object(null)}
    {...null} // {}

  9.扩展运算符可以用于合并两个对象。(如果出现重复的属性，后面的会把前面的覆盖掉)
    let ab = { ...a, ...b };
    // 等同于
    let ab = Object.assign({}, a, b);

  